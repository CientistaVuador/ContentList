/*
 * This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information, please refer to <https://unlicense.org>
 */
package matinilad.contentlist.ui.gui;

import java.awt.Toolkit;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicLong;
import javax.swing.SwingUtilities;
import matinilad.contentlist.ContentEntry;
import matinilad.contentlist.ContentListUtils;
import matinilad.contentlist.ContentType;
import matinilad.contentlist.ui.UIUtils;

/**
 *
 * @author Cien
 */
@SuppressWarnings("serial")
public class PathValidateDialog extends javax.swing.JDialog implements ContentEntry.ValidationCallbacks {

    private static final AtomicLong instances = new AtomicLong(0);

    private final long instance = instances.getAndIncrement();

    private final Thread thread;
    private final ContentEntry[] entries;
    private final Path baseDirectory;

    /**
     * Creates new form Validate
     */
    public PathValidateDialog(
            ContentEntry[] entries, Path baseDirectory,
            java.awt.Frame parent, boolean modal
    ) {
        super(parent, modal);
        initComponents();
        Objects.requireNonNull(entries, "entries is null");
        Objects.requireNonNull(baseDirectory, "baseDirectory is null");
        this.entries = entries;
        this.baseDirectory = baseDirectory;

        this.thread = new Thread(() -> {
            try {
                run();
            } catch (Throwable t) {
                SwingUtilities.invokeLater(() -> {
                    onException(t);
                });
            }
            SwingUtilities.invokeLater(() -> {
                this.cancelButton.setEnabled(false);
            });
        });
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        currentEntry = new javax.swing.JTextArea();
        jPanel2 = new javax.swing.JPanel();
        currentFile = new javax.swing.JLabel();
        currentFileProgressBar = new javax.swing.JProgressBar();
        currentFileStatus = new javax.swing.JLabel();
        existsCheckBox = new javax.swing.JCheckBox();
        typeCheckBox = new javax.swing.JCheckBox();
        sizeCheckBox = new javax.swing.JCheckBox();
        sampleCheckBox = new javax.swing.JCheckBox();
        hashCheckBox = new javax.swing.JCheckBox();
        cancelButton = new javax.swing.JButton();
        entriesStatus = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Validating");
        setMinimumSize(new java.awt.Dimension(600, 347));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
        });

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Entry"));

        currentEntry.setEditable(false);
        currentEntry.setColumns(20);
        currentEntry.setRows(5);
        currentEntry.setText("/path/to/the/entry\nType: FILE\nCreated on: 12/54/87 12:45\nModified on: 12/65/98 65:12\nSize: 10GB 20MB 30KB 20 Bytes\nSHA256: asdasdasdasdasdasdasdasdas\nSample: asdasdasdasdasdasdasdasdas\n100 Files, 100 Directories");
        jScrollPane1.setViewportView(currentEntry);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 144, Short.MAX_VALUE)
                .addContainerGap())
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("File"));

        currentFile.setText("C:\\path\\to\\the\\file.txt");
        currentFile.setMaximumSize(new java.awt.Dimension(494, 16));
        currentFile.setMinimumSize(new java.awt.Dimension(494, 16));
        currentFile.setPreferredSize(new java.awt.Dimension(494, 16));

        currentFileStatus.setText("96.55% - 10TB 10GB 10MB 10KB 102 Bytes out of 10TB 10GB 10MB 12KB 150 Bytes - 150 MB/s");
        currentFileStatus.setMaximumSize(new java.awt.Dimension(494, 16));
        currentFileStatus.setMinimumSize(new java.awt.Dimension(494, 16));
        currentFileStatus.setPreferredSize(new java.awt.Dimension(494, 16));

        existsCheckBox.setSelected(true);
        existsCheckBox.setText("Exists");
        existsCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                existsCheckBoxActionPerformed(evt);
            }
        });

        typeCheckBox.setSelected(true);
        typeCheckBox.setText("Type");
        typeCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                typeCheckBoxActionPerformed(evt);
            }
        });

        sizeCheckBox.setText("Size");
        sizeCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sizeCheckBoxActionPerformed(evt);
            }
        });

        sampleCheckBox.setText("Sample");
        sampleCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sampleCheckBoxActionPerformed(evt);
            }
        });

        hashCheckBox.setText("Hash");
        hashCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                hashCheckBoxActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(currentFileProgressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(currentFileStatus, javax.swing.GroupLayout.DEFAULT_SIZE, 566, Short.MAX_VALUE)
                    .addComponent(currentFile, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(existsCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(typeCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sizeCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sampleCheckBox)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(hashCheckBox)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(currentFile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(currentFileProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(currentFileStatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(existsCheckBox)
                    .addComponent(typeCheckBox)
                    .addComponent(sizeCheckBox)
                    .addComponent(sampleCheckBox)
                    .addComponent(hashCheckBox)))
        );

        cancelButton.setText("Cancel");
        cancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelButtonActionPerformed(evt);
            }
        });

        entriesStatus.setText("1000 Accepted, 1000 Refused, 1000 Processed");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(entriesStatus, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(cancelButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cancelButton)
                    .addComponent(entriesStatus))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void log(int level, String text) {
        if (getParent() instanceof MainWindow w) {
            String[] lines = text.lines().toArray(String[]::new);
            for (String line : lines) {
                w.println(level, "V" + this.instance + " " + line);
            }
        }
    }

    private void run() throws Throwable {
        SwingUtilities.invokeLater(() -> {
            log(MainWindow.INFO_LEVEL, "Running");
        });
        for (ContentEntry e : this.entries) {
            e.validate(this.baseDirectory, this);
            entryFinish();
        }
        SwingUtilities.invokeLater(() -> {
            if (this.refused != 0) {
                setTitle("Done ("+this.refused+" Failed!)");
            } else {
                setTitle("Done");
            }
            log(MainWindow.INFO_LEVEL, "Done");
        });
    }

    private void existsCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_existsCheckBoxActionPerformed
        this.existsCheckBox.setSelected(!this.existsCheckBox.isSelected());
    }//GEN-LAST:event_existsCheckBoxActionPerformed

    private void typeCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_typeCheckBoxActionPerformed
        this.typeCheckBox.setSelected(!this.typeCheckBox.isSelected());
    }//GEN-LAST:event_typeCheckBoxActionPerformed

    private void sizeCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sizeCheckBoxActionPerformed
        this.sizeCheckBox.setSelected(!this.sizeCheckBox.isSelected());
    }//GEN-LAST:event_sizeCheckBoxActionPerformed

    private void sampleCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sampleCheckBoxActionPerformed
        this.sampleCheckBox.setSelected(!this.sampleCheckBox.isSelected());
    }//GEN-LAST:event_sampleCheckBoxActionPerformed

    private void hashCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_hashCheckBoxActionPerformed
        this.hashCheckBox.setSelected(!this.hashCheckBox.isSelected());
    }//GEN-LAST:event_hashCheckBoxActionPerformed

    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
        this.currentEntry.setText("");
        this.currentFile.setText("");
        this.currentFileStatus.setText("");
        this.existsCheckBox.setSelected(false);
        this.typeCheckBox.setSelected(false);
        this.sizeCheckBox.setSelected(false);
        this.sampleCheckBox.setSelected(false);
        this.hashCheckBox.setSelected(false);
        this.entriesStatus.setText("");

        this.thread.start();
        log(MainWindow.INFO_LEVEL, "Processing thread initiated");
    }//GEN-LAST:event_formWindowOpened
    
    private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed
        if (this.thread.isAlive()) {
            setTitle("Canceled");
            log(MainWindow.INFO_LEVEL, "Canceled");
            this.thread.interrupt();
        } else {
            this.cancelButton.setEnabled(false);
        }
    }//GEN-LAST:event_cancelButtonActionPerformed

    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
        if (this.thread.isAlive()) {
            log(MainWindow.INFO_LEVEL, "Canceled");
            this.thread.interrupt();
        }
    }//GEN-LAST:event_formWindowClosed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton cancelButton;
    private javax.swing.JTextArea currentEntry;
    private javax.swing.JLabel currentFile;
    private javax.swing.JProgressBar currentFileProgressBar;
    private javax.swing.JLabel currentFileStatus;
    private javax.swing.JLabel entriesStatus;
    private javax.swing.JCheckBox existsCheckBox;
    private javax.swing.JCheckBox hashCheckBox;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JCheckBox sampleCheckBox;
    private javax.swing.JCheckBox sizeCheckBox;
    private javax.swing.JCheckBox typeCheckBox;
    // End of variables declaration//GEN-END:variables
    
    private void onException(Throwable t) {
        if (t == null || t instanceof InterruptedException) {
            return;
        }
        setTitle("Error!");
        Toolkit.getDefaultToolkit().beep();
        log(MainWindow.ERROR_LEVEL, "Fatal error!");
        log(MainWindow.ERROR_LEVEL, UIUtils.stacktraceOf(t));
    }

    private ContentEntry entry = null;
    private Path path = null;
    private boolean currentEntryRefused = false;
    private long initialTime = System.currentTimeMillis();
    private long size = 0;
    private int accepted = 0;
    private int refused = 0;

    @Override
    public void setEntry(ContentEntry entry) throws IOException, InterruptedException {
        SwingUtilities.invokeLater(() -> {
            this.entry = entry;
            this.path = null;
            this.currentEntryRefused = false;
            this.initialTime = System.currentTimeMillis();
            this.size = 0;

            StringBuilder b = new StringBuilder();
            b.append(entry.getPath().toString()).append("\n");
            b.append("Type: ").append(entry.getType()).append("\n");
            b.append("Created on: ").append(UIUtils.asShortLocalizedDateTime(entry.getCreated())).append("\n");
            b.append("Modified on: ").append(UIUtils.asShortLocalizedDateTime(entry.getModified())).append("\n");
            b.append("Size: ").append(UIUtils.formatBytes(entry.getSize())).append("\n");
            if (entry.getType().equals(ContentType.DIRECTORY)) {
                b.append(entry.getFiles()).append(" Files, ").append(entry.getDirectories()).append(" Directories").append("\n");
            }
            byte[] sha256 = entry.getSha256();
            byte[] sample = entry.getSample();
            if (sha256 != null) {
                b.append("SHA256: ").append(ContentListUtils.toHexString(sha256)).append("\n");
            }
            if (sample != null) {
                b.append("Sample: ").append(ContentListUtils.toHexString(sample)).append("\n");
            }
            this.currentEntry.setText(b.toString());
            this.currentFile.setText("");

            this.existsCheckBox.setSelected(false);
            this.typeCheckBox.setSelected(false);
            this.sizeCheckBox.setSelected(false);
            this.sampleCheckBox.setSelected(false);
            this.hashCheckBox.setSelected(false);

            this.currentFileProgressBar.setValue(0);
            this.currentFileStatus.setText("");

            this.currentEntryRefused = false;
            this.initialTime = System.currentTimeMillis();
        });
    }

    @Override
    public void setPath(Path path) throws IOException, InterruptedException {
        SwingUtilities.invokeLater(() -> {
            this.path = path;
            this.currentFile.setText(path.toString());
        });
    }

    @Override
    public void setSize(long size) throws IOException, InterruptedException {
        SwingUtilities.invokeLater(() -> {
            this.size = size;
        });
    }

    @Override
    public void progressUpdate(long bytes) throws IOException, InterruptedException {
        SwingUtilities.invokeLater(() -> {
            if (bytes != 0) {
                this.currentFileProgressBar.setValue((int) ((((double) bytes) / this.size) * 100));
            }
            long time = ((System.currentTimeMillis() - this.initialTime) / 1000);
            long averageSpeed;
            if (time != 0) {
                averageSpeed = bytes / time;
            } else {
                averageSpeed = 0;
            }
            this.currentFileStatus.setText(UIUtils.formatPercentage(bytes, this.size) + " - " + UIUtils.formatBytes(bytes) + " out of " + UIUtils.formatBytes(this.size) + " - " + UIUtils.formatSpeed(averageSpeed));
        });
    }

    @Override
    public void accepted(ContentEntry.ValidationReason reason) throws IOException, InterruptedException {
        SwingUtilities.invokeLater(() -> {
            switch (reason) {
                case EXISTS -> {
                    this.existsCheckBox.setSelected(true);
                }
                case TYPE -> {
                    this.typeCheckBox.setSelected(true);
                }
                case SIZE -> {
                    this.sizeCheckBox.setSelected(true);
                }
                case HASH -> {
                    this.hashCheckBox.setSelected(true);
                }
                case SAMPLE -> {
                    this.sampleCheckBox.setSelected(true);
                }
            }
        });
    }

    @Override
    public void refused(ContentEntry.ValidationReason reason, Object foundValue) throws IOException, InterruptedException {
        SwingUtilities.invokeLater(() -> {
            log(MainWindow.WARN_LEVEL, "WARNING!");
            log(MainWindow.WARN_LEVEL, "Refused: " + this.entry.getPath().toString());
            log(MainWindow.WARN_LEVEL, "Real Path: " + this.path.toString());
            switch (reason) {
                case EXISTS -> {
                    log(MainWindow.WARN_LEVEL, "Reason: Does not exists!");
                }
                case TYPE -> {
                    log(MainWindow.WARN_LEVEL, "Reason: Expected type " + this.entry.getType() + ", found " + foundValue);
                }
                case SIZE -> {
                    log(MainWindow.WARN_LEVEL, "Reason: Wrong Size! Expected " + UIUtils.formatBytes(this.entry.getSize()) + "; found " + UIUtils.formatBytes((long) foundValue));
                }
                case SAMPLE -> {
                    log(MainWindow.WARN_LEVEL, "Reason: Wrong sample!");
                    log(MainWindow.WARN_LEVEL, " Expected: " + ContentListUtils.toHexString(this.entry.getSample()));
                    log(MainWindow.WARN_LEVEL, "    Found: " + ContentListUtils.toHexString((byte[]) foundValue));
                }
                case HASH -> {
                    log(MainWindow.WARN_LEVEL, "Reason: Wrong hash!");
                    log(MainWindow.WARN_LEVEL, " Expected: " + ContentListUtils.toHexString(this.entry.getSha256()));
                    log(MainWindow.WARN_LEVEL, "    Found: " + ContentListUtils.toHexString((byte[]) foundValue));
                }
            }
            this.currentEntryRefused = true;
        });
    }

    public void entryFinish() {
        SwingUtilities.invokeLater(() -> {
            if (this.currentEntryRefused) {
                this.refused++;
            } else {
                this.accepted++;
            }
            int processed = (this.accepted + this.refused);
            int left = this.entries.length - processed;
            this.entriesStatus.setText(this.accepted + " Accepted, " + this.refused + " Refused, " + processed + " Processed, " + left + " Left.");
        });
    }
}
